{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nexports.__esModule = true;\nexports[\"default\"] = setIn;\n\nvar _toPath2 = _interopRequireDefault(require(\"lodash/toPath\"));\n\nvar _immutable = require(\"immutable\");\n\nvar arrayPattern = /\\[(\\d+)\\]/;\n\nvar undefinedArrayMerge = function undefinedArrayMerge(previous, next) {\n  return next !== undefined ? next : previous;\n};\n\nvar mergeLists = function mergeLists(originalList, value) {\n  if (originalList && _immutable.List.isList(originalList)) {\n    return originalList.map(function (originalListValue, index) {\n      return undefinedArrayMerge(value.get(index), originalListValue);\n    }).concat(value.slice(originalList.size));\n  }\n\n  return value;\n};\n\nvar assureComplexProps = function assureComplexProps(state, path) {\n  for (var pathPart = 1; pathPart < path.length; ++pathPart) {\n    var nextPart = path.slice(0, pathPart);\n\n    if (state.getIn(nextPart) == null) {\n      return state.setIn(nextPart, new _immutable.Map());\n    }\n  }\n\n  return state;\n};\n/*\n * ImmutableJS' setIn function doesn't support array (List) creation\n * so we must pre-insert all arrays in the path ahead of time.\n *\n * Additionally we must also pre-set a dummy Map at the location\n * of an array index if there's parts that come afterwards because\n * the setIn function uses `{}` to mark an unset value instead of\n * undefined (which is the case for list / arrays).\n */\n\n\nfunction setIn(state, field, value) {\n  var path = (0, _toPath2[\"default\"])(field);\n\n  if (!field || typeof field !== 'string' || !arrayPattern.test(field)) {\n    var newState = assureComplexProps(state, path);\n    return newState.setIn(path, value);\n  }\n\n  return state.withMutations(function (mutable) {\n    var _loop = function _loop(pathIndex) {\n      var nextPart = path[pathIndex + 1];\n\n      if (isNaN(nextPart)) {\n        return \"continue\";\n      }\n\n      mutable = mutable.updateIn(path.slice(0, pathIndex + 1), function (value) {\n        return mergeLists(value, new _immutable.List().set(parseInt(nextPart, 10), new _immutable.Map()));\n      });\n    };\n\n    for (var pathIndex = 0; pathIndex < path.length - 1; ++pathIndex) {\n      var _ret = _loop(pathIndex);\n\n      if (_ret === \"continue\") continue;\n    }\n\n    return mutable.setIn(path, value);\n  });\n}","map":{"version":3,"names":["_interopRequireDefault","require","exports","__esModule","setIn","_toPath2","_immutable","arrayPattern","undefinedArrayMerge","previous","next","undefined","mergeLists","originalList","value","List","isList","map","originalListValue","index","get","concat","slice","size","assureComplexProps","state","path","pathPart","length","nextPart","getIn","Map","field","test","newState","withMutations","mutable","_loop","pathIndex","isNaN","updateIn","set","parseInt","_ret"],"sources":["G:/ewa/node_modules/redux-form/lib/structure/immutable/setIn.js"],"sourcesContent":["\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nexports.__esModule = true;\nexports[\"default\"] = setIn;\n\nvar _toPath2 = _interopRequireDefault(require(\"lodash/toPath\"));\n\nvar _immutable = require(\"immutable\");\n\nvar arrayPattern = /\\[(\\d+)\\]/;\n\nvar undefinedArrayMerge = function undefinedArrayMerge(previous, next) {\n  return next !== undefined ? next : previous;\n};\n\nvar mergeLists = function mergeLists(originalList, value) {\n  if (originalList && _immutable.List.isList(originalList)) {\n    return originalList.map(function (originalListValue, index) {\n      return undefinedArrayMerge(value.get(index), originalListValue);\n    }).concat(value.slice(originalList.size));\n  }\n\n  return value;\n};\n\nvar assureComplexProps = function assureComplexProps(state, path) {\n  for (var pathPart = 1; pathPart < path.length; ++pathPart) {\n    var nextPart = path.slice(0, pathPart);\n\n    if (state.getIn(nextPart) == null) {\n      return state.setIn(nextPart, new _immutable.Map());\n    }\n  }\n\n  return state;\n};\n/*\n * ImmutableJS' setIn function doesn't support array (List) creation\n * so we must pre-insert all arrays in the path ahead of time.\n *\n * Additionally we must also pre-set a dummy Map at the location\n * of an array index if there's parts that come afterwards because\n * the setIn function uses `{}` to mark an unset value instead of\n * undefined (which is the case for list / arrays).\n */\n\n\nfunction setIn(state, field, value) {\n  var path = (0, _toPath2[\"default\"])(field);\n\n  if (!field || typeof field !== 'string' || !arrayPattern.test(field)) {\n    var newState = assureComplexProps(state, path);\n    return newState.setIn(path, value);\n  }\n\n  return state.withMutations(function (mutable) {\n    var _loop = function _loop(pathIndex) {\n      var nextPart = path[pathIndex + 1];\n\n      if (isNaN(nextPart)) {\n        return \"continue\";\n      }\n\n      mutable = mutable.updateIn(path.slice(0, pathIndex + 1), function (value) {\n        return mergeLists(value, new _immutable.List().set(parseInt(nextPart, 10), new _immutable.Map()));\n      });\n    };\n\n    for (var pathIndex = 0; pathIndex < path.length - 1; ++pathIndex) {\n      var _ret = _loop(pathIndex);\n\n      if (_ret === \"continue\") continue;\n    }\n\n    return mutable.setIn(path, value);\n  });\n}"],"mappings":"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"},"metadata":{},"sourceType":"script"}